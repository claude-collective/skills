# SCSS Modules cva Integration Examples

> Class Variance Authority (cva) integration patterns for SCSS Modules. See [SKILL.md](../SKILL.md) for core concepts and [core.md](core.md) for foundational patterns.

---

## Pattern 12: cva (Class Variance Authority) Integration

### Implementation

cva provides type-safe variant management for components with multiple variants. It works seamlessly with SCSS Modules.

```typescript
import { cva, type VariantProps } from "class-variance-authority";
import clsx from "clsx";
import styles from "./alert.module.scss";

const ANIMATION_DURATION_MS = 200;

const alertVariants = cva("alert", {
  variants: {
    variant: {
      info: clsx(styles.alert, styles.alertInfo),
      warning: clsx(styles.alert, styles.alertWarning),
      error: clsx(styles.alert, styles.alertError),
      success: clsx(styles.alert, styles.alertSuccess),
    },
    size: {
      sm: clsx(styles.alert, styles.alertSm),
      md: clsx(styles.alert, styles.alertMd),
      lg: clsx(styles.alert, styles.alertLg),
    },
  },
  defaultVariants: {
    variant: "info",
    size: "md",
  },
});

export type AlertProps = React.ComponentProps<"div"> &
  VariantProps<typeof alertVariants>;

export const Alert = ({ variant, size, className, ...props }: AlertProps) => {
  return (
    <div
      className={clsx(alertVariants({ variant, size, className }))}
      style={{ transition: `all ${ANIMATION_DURATION_MS}ms ease` }}
      {...props}
    />
  );
};
```

**Why good:** cva provides type-safe variant props with autocomplete, defaultVariants prevent undefined behavior, named constant for animation duration prevents magic numbers, VariantProps extracts correct TypeScript types from cva definition

### Button Example with Full States

```scss
// packages/ui/src/components/button/button.module.scss
.btn {
  display: flex;
  align-items: center;
  justify-content: center;

  font-size: var(--text-size-body);
  font-weight: 600;

  border-radius: var(--radius-sm);
  border: 1px solid transparent;

  cursor: pointer;
  transition: all 0.2s ease;

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
}

.btnDefault {
  background-color: var(--color-surface-base);
  color: var(--color-text-default);
  border-color: var(--color-surface-subtle);

  &:hover:not(:disabled) {
    background-color: var(--color-surface-subtle);
  }

  &[data-active="true"] {
    color: var(--color-text-muted);
    background: var(--color-surface-strong);
  }
}

.btnGhost {
  background-color: transparent;

  &:hover:not(:disabled) {
    background-color: var(--color-surface-subtle);
  }
}

.btnSizeDefault {
  padding: var(--space-md);
}

.btnSizeLarge {
  padding: var(--space-xlg) var(--space-xxlg);
}

.btnSizeIcon {
  padding: var(--space-md);
  aspect-ratio: 1;
}
```

**Why good:** design tokens ensure consistency across components, data-attributes for state styling separate state from presentation, scoped styles prevent global namespace pollution, disabled and hover states properly handled

### Bad Example - Hardcoded Values

```scss
.button {
  padding: 12px 24px; // Magic numbers
  background: #3b82f6; // Hardcoded color
  border-radius: 8px; // Magic number
}

.button.active {
  background: #2563eb; // className toggling for state
}
```

**Why bad:** hardcoded values prevent theme switching and break design system consistency, magic numbers are unmaintainable and inconsistent across components, className toggling for state is harder to manage than data-attributes
